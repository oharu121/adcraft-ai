rules_version = '2';

/**
 * Product Intelligence Agent - Firestore Security Rules
 * 
 * Implements security rules for the Product Intelligence Agent system
 * including sessions, chat history, product analyses, and agent handoffs.
 * 
 * Collections:
 * - sessions: Legacy video sessions (existing system)
 * - videoJobs: Legacy video job tracking (existing system)  
 * - costs: Cost tracking entries (existing system)
 * - productIntelligenceSessions: Product Intelligence Agent sessions
 * - productIntelligenceChats: Chat messages for Product Intelligence
 * - productAnalyses: Product analysis results (auto-cleanup)
 * - agentHandoffs: Agent handoff coordination data
 */

service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper functions for common security patterns
    
    // Check if request is coming from authorized service account
    function isServiceAccount() {
      return request.auth != null 
        && request.auth.token.firebase != null 
        && request.auth.token.firebase.sign_in_provider == 'custom';
    }
    
    // Check if document is not expired (has expiresAt field in future)
    function isNotExpired() {
      return !('expiresAt' in resource.data) 
        || resource.data.expiresAt > request.time;
    }
    
    // Check if session belongs to current client (IP-based matching)
    function isSessionOwner(sessionData) {
      return sessionData.user.ipAddress == request.headers['x-forwarded-for'][0] 
        || sessionData.user.ipAddress == request.headers['x-real-ip']
        || sessionData.user.ipAddress == request.headers['cf-connecting-ip'];
    }
    
    // Validate session data structure
    function isValidSessionData() {
      return request.resource.data.keys().hasAll([
        'sessionId', 'status', 'currentAgent', 'user', 'product', 
        'conversation', 'progress', 'costs', 'performance', 'handoff', 
        'rateLimit', 'health', 'metadata'
      ])
      && request.resource.data.sessionId is string
      && request.resource.data.status in ['active', 'completed', 'failed', 'expired']
      && request.resource.data.currentAgent in ['product-intelligence', 'creative-director', 'video-producer'];
    }
    
    // Validate chat message structure
    function isValidChatMessage() {
      return request.resource.data.keys().hasAll(['id', 'sessionId', 'type', 'content', 'timestamp'])
      && request.resource.data.type in ['user', 'agent', 'system']
      && request.resource.data.content is string
      && request.resource.data.sessionId is string;
    }
    
    // Rate limiting check (basic document count per IP)
    function isWithinRateLimit() {
      // Allow service accounts to bypass rate limiting
      return isServiceAccount() 
        || get(/databases/$(database)/documents/rateLimits/$(request.headers['x-forwarded-for'][0])).data.requestCount < 100;
    }

    // Legacy collections (existing system) - maintain backward compatibility
    
    // Video sessions collection (legacy)
    match /sessions/{sessionId} {
      // Read: Allow service account or session owner
      allow read: if isServiceAccount() 
        || (request.auth != null && isNotExpired());
      
      // Write: Service account only
      allow write: if isServiceAccount();
      
      // Delete: Service account only (for cleanup)
      allow delete: if isServiceAccount();
    }
    
    // Video jobs collection (legacy)
    match /videoJobs/{jobId} {
      // Read: Allow service account
      allow read: if isServiceAccount();
      
      // Write: Service account only
      allow write: if isServiceAccount();
      
      // Delete: Service account only (for cleanup)
      allow delete: if isServiceAccount();
    }
    
    // Cost tracking collection (legacy)
    match /costs/{costId} {
      // Read: Service account only
      allow read: if isServiceAccount();
      
      // Write: Service account only  
      allow write: if isServiceAccount();
      
      // Delete: Service account only (for cleanup)
      allow delete: if isServiceAccount();
    }

    // Product Intelligence Agent specific collections
    
    // Product Intelligence Sessions
    match /productIntelligenceSessions/{sessionId} {
      // Read: Service account or session owner (IP-based)
      allow read: if isServiceAccount() 
        || (isNotExpired() && isSessionOwner(resource.data));
      
      // Create: Service account only with valid data structure
      allow create: if isServiceAccount() 
        && isValidSessionData()
        && isWithinRateLimit();
      
      // Update: Service account only with valid data
      allow update: if isServiceAccount() 
        && isValidSessionData()
        && resource.data.sessionId == request.resource.data.sessionId; // Prevent session ID changes
      
      // Delete: Service account only (for cleanup of expired sessions)
      allow delete: if isServiceAccount() 
        && (!isNotExpired() || request.time > resource.data.metadata.expiresAt);
    }
    
    // Product Intelligence Chat Messages
    match /productIntelligenceChats/{messageId} {
      // Read: Service account only (chat history accessed through sessions)
      allow read: if isServiceAccount();
      
      // Create: Service account only with valid message structure
      allow create: if isServiceAccount() 
        && isValidChatMessage()
        && isWithinRateLimit();
      
      // Update: Not allowed (messages are immutable)
      allow update: if false;
      
      // Delete: Service account only (for cleanup)
      allow delete: if isServiceAccount();
    }
    
    // Product Analyses (with auto-cleanup)
    match /productAnalyses/{sessionId} {
      // Read: Service account only
      allow read: if isServiceAccount() && isNotExpired();
      
      // Create: Service account only
      allow create: if isServiceAccount() 
        && request.resource.data.keys().hasAll(['sessionId', 'analysis', 'version', 'createdAt', 'expiresAt'])
        && request.resource.data.sessionId == sessionId;
      
      // Update: Service account only
      allow update: if isServiceAccount() 
        && resource.data.sessionId == request.resource.data.sessionId;
      
      // Delete: Service account only or expired documents
      allow delete: if isServiceAccount() 
        && (!isNotExpired() || request.time > resource.data.expiresAt);
    }
    
    // Agent Handoff coordination
    match /agentHandoffs/{handoffId} {
      // Read: Service account only
      allow read: if isServiceAccount();
      
      // Create: Service account only with valid handoff structure
      allow create: if isServiceAccount() 
        && request.resource.data.keys().hasAll(['sessionId', 'fromAgent', 'toAgent', 'handoffTimestamp', 'serializedData', 'validationResults', 'status', 'metadata'])
        && request.resource.data.fromAgent in ['product-intelligence', 'creative-director', 'video-producer']
        && request.resource.data.toAgent in ['product-intelligence', 'creative-director', 'video-producer']
        && request.resource.data.status in ['pending', 'in_progress', 'completed', 'failed'];
      
      // Update: Service account only
      allow update: if isServiceAccount() 
        && resource.data.sessionId == request.resource.data.sessionId;
      
      // Delete: Service account only (for cleanup)
      allow delete: if isServiceAccount();
    }

    // Rate limiting collection (for basic rate limiting)
    match /rateLimits/{identifier} {
      // Read: Service account only
      allow read: if isServiceAccount();
      
      // Write: Service account only
      allow write: if isServiceAccount();
      
      // Delete: Service account only (for cleanup)
      allow delete: if isServiceAccount();
    }

    // Security monitoring collection (for security events)
    match /securityEvents/{eventId} {
      // Read: Service account only
      allow read: if isServiceAccount();
      
      // Create: Service account only
      allow create: if isServiceAccount() 
        && request.resource.data.keys().hasAll(['timestamp', 'type', 'severity', 'source', 'description']);
      
      // Update: Not allowed (security events are immutable)
      allow update: if false;
      
      // Delete: Service account only (for cleanup after investigation)
      allow delete: if isServiceAccount();
    }

    // System health monitoring collection
    match /healthMetrics/{metricId} {
      // Read: Service account only
      allow read: if isServiceAccount();
      
      // Write: Service account only
      allow write: if isServiceAccount();
      
      // Delete: Service account only (for cleanup)
      allow delete: if isServiceAccount();
    }

    // Default deny rule - no other collections are allowed
    match /{document=**} {
      allow read, write: if false;
    }
  }
}